\section{Introduction}

%Programmers spend tremendous efforts dealing with bug fixing. 

%
 Automatic program repair is the  process of modifying the program if it does not satisfy the specification in the form of constraints~\cite{divya:tacas11},  pre- and post- conditions~\cite{autofix:tse14}, or test suites~\cite{par:icse13, angelix:icse16}.  The output of the repair task is an alternative implementation that meets the specification. The last few years have seen a lot of progress in automatic program repair~\cite{genprog:tse12, Debroy:icst10, spr:fse15}.  These approaches try to correct the faulty program by mutating suspicious statements~\cite{Debroy:icst10},   applying evolutionary algorithm to search for repair candidates~\cite{genprog:tse12}, inferring conditional substitutions systematically~\cite{spr:fse15}, or leveraging  symbolic analysis and constraint solving to find a repair~\cite{semfix:icse13}. %Automatic program repair usually consists of two general phases: fault localization that identifies the root cause of faults and repair inference that generates desired functions. 
These tools, however,  
are confined to inferring new expressions for conditions~\cite{spr:fse15, nopol:cstva14} or reusing existing statements~\cite{genprog:tse12}. \todo{They have limited repairability to fix faults resulting from missing statements  that do not exist in the current context.} Due to the large search space of repair candidates,  it remains a challenge to synthesize a correct program repair efficiently at the statement level.


We present \tool, a program repair tool that addresses this challenge by translating a faulty program to a partial non-deterministic implementation and leveraging off-the-shelf program synthesizer to fill in the ``holes'' of the partial program. If there exists a replacement that  satisfies all test assertions,  the synthesizer will return this concrete substitution as a program repair. 


To speed up our repair process, we rank suspicious program locations using the invocation order of  statements and  spectra-based fault localization technique~\cite{tarantula:ase05}.  We prioritize program locations that are called later during executions leading to failing test assertions. These ``later'' locations allow us   to reuse as much of the original implementation as possible and reduce the size of expressions given to subsequent expensive techniques.  


For each suspicious location, \tool introduces  non-deterministic placeholders based on pre-defined  repair skeletons called ``repair hypotheses''.  The repair  hypothesis for an assignment is a partial statement with expression candidates  and  the assignment combinator ``\codefont{=}''.   We collect all  candidates of a specific type. These candidates are derived from visible variables with no more than a small size of field dereferences.    For example, using no more than two field dereferences, the expressions of the type \codefont{int} derived from the variable \codefont{LinkedList l}  are \{\codefont{l.size, l.head.element}\}.   


Lastly, \todo{the non-deterministic  program with candidates  is verified by the Sketch synthesizer with the SAT solver~\cite{sketch:sttt13} against  the  given test suite. }   If there exists a concrete substitution for each ``hole'' such that the replaced program  satisfies all test assertions, \tool  returns this substitution as a ``correct'' repair with respect to the user-provided test suite. To fix bugs at multiple locations,  \tool incrementally  eliminates failing test assertions and generates new hypotheses based on the updated program. 

We evaluate \tool on 35 faults from students' pop quizzes in  7 data structure subjects. To generate program repairs for faulty programs, we  use bounded exhaustive test suite generated by the  constraint-based test input generation tool---Korat~\cite{korat:issta02}.  
The experiment illustrates that  \tool is able to generate program repairs for  missing conditions and statements.  We also demonstrate that these faults are hard to fix using state-of-the-art program repair tools,  such as SPR~\cite{spr:fse15} and Genprog~\cite{genprog:tse12}.  SPR generates no correct fix while GenProg generates two correct fixes based on the exhaustive test suite. \tool successfully generates 30 correct fixes with the exhaustive test suite and 14 correct repairs with a subset of the exhaustive test suite. The results can be found at~\cite{git:compareRepo}. 

In summary, we make the following contributions: 

\begin{itemize}
\item \textbf{Fault Localization}.  We present a fault localization technique  considering both the invocation order and the spectra-based suspiciousness value~\cite{tarantula:ase05}. 
\todo{Our experiment shows that this approach is in practice sufficient to save calls to the synthesizer and prune  repair candidates. }

\item \textbf{Repair Hypothesis Generation}.  We introduce two  repair hypotheses to fix faulty assignments and if-conditions followed by return statements that return true or false. The placeholders in a hypothesis are replaced by expression candidates within a given bound.  Therefore, \tool is not confined to generating repairs at the expression level~\cite{nopol:cstva14, spr:fse15}, rather, it   creates new statements that do not exist in the current program.  It can also incrementally fix  faults at multiple locations based on the test suite. 



\item \textbf{Comparison Results}. We demonstrate \tool's efficacy to repair faulty assignments and if-return statements  with a benchmark of 35 faults from students' data structure subjects. The result shows that for these small but complex programs,  \tool can effectively repair errors  due to  missing statements and faults in multiple locations. Our comparison with general-purpose repair tools  illustrates that these tools are not as sufficient as \tool in addressing these errors. 

\end{itemize}

%The paper is organized as follows: We first present an motivating example to illustrate the problem in Section~\ref{sec:motivate}. In Section~\ref{sec:approach}, we describe  our approach that  prioritizes fault locations and generates repair hypotheses. We evaluate the repairability of \tool  and the effectiveness of the ranking strategy in Section~\ref{sec:eval}, followed by the description of other techniques of program repair and program synthesis in Section~\ref{sec:related}. We discuss the threads to validity in Section~\ref{sec:validity} and conclude in Section~\ref{sec:conclude}. 
% \codefont{Entry} that can be derived with visible 
%variables: \codefont{list.head, entry, entry.previous,} and \codefont{entry.next}. 

