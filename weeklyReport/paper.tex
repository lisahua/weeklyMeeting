%\documentclass[natbib,preprint]{sigplanconf}
% \documentclass[conference]{IEEEtran}
\documentclass{sig-alternate}
\usepackage{fancybox}
\usepackage{cite}
\usepackage{color,soul}
\usepackage{hyperref}
\usepackage{algorithmic}
\usepackage{flushend}
\usepackage{fancyvrb}
\usepackage[normalem]{ulem}
\usepackage{graphicx}
\usepackage[lined, algonl, ruled, boxed]{algorithm2e} 
\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{listings}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{xspace}
\usepackage[usenames,dvipsnames]{xcolor}

% \usepackage{fancybox}
% \usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
% \captionsetup[table]{skip=10pt}

\newcommand{\tool}{\textsc{Niche}\xspace}
\newcommand{\fixme} [1] {\textcolor{red}{{\it FIXME}: #1}}
\newcommand{\delete} [1] {\textcolor{red}{#1}}
\newcommand{\add} [1] {\textcolor{blue}{#1}}
% \newcommand{\javac}{javac\xspace} % This package lets you punctuate \javac normally and get good spacing, e.g., \javac.  gives you: javac.
\newcommand{\codefont}[1]{\footnotesize{\texttt{#1}}\normalsize}
\newcommand{\todo} [1]{\textcolor{blue}{{\sf TODO}: #1}}
\newcommand{\hlc}[2][yellow]{ {\sethlcolor{#1} \hl{#2}} }


% \lstset{frame=tb,
%   language=Java,
%   showstringspaces=false,
%   columns=flexible,
%   basicstyle={\ttfamily\footnotesize},
%   numberstyle=\tiny\color{gray},
%   keywordstyle=\color{blue},
%   commentstyle=\color{dkgreen},
%   stringstyle=\color{mauve},
%   breaklines=true,
%   breakatwhitespace=true,
%   tabsize=3
% }



\begin{document}

%\conferenceinfo{Mystery'09,} {January 1, 2009, Austin, TX.}
%\CopyrightYear{2009}
%\copyrightdata{2009}


%\title{How Universal are Naming Rules?}

\title{Weekly Meeting } %

% \numberofauthors{3} 
% \author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%

\numberofauthors{1} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
%\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
%\alignauthor
%Lisa Hua$^{\dag}$ Na Meng$^{\dag}$ Miryung Kim$^{\ast}$ Kathryn S. McKinley$^{\ddag}$\\
%\affaddr{$^{\dag}$\normalsize{The University of Texas at Austin~~~~~~~$^{\ast}$University of California, Los Angeles~~~~~~~$^{\ddag}$Microsoft Research}}\\
%\email{\normalsize{\{lisahua@, mengna09@cs\}.utexas.edu, miryung@cs.ucla.edu, mckinley@microsoft.com}}
%}

\maketitle

\section{Problem Statement}

Developers frequently use source code examples as the basis for interacting with an  application programming interface (API) to obtain the needed functionality.  In this case, the source code example serves as the explicit origin for a reuse task when it fits a developer's context sufficiently well~\cite{Frakes:reuseStatus05, Parsons:cognitiveReuse04}. We define a reuse task as a series of copy-paste-modify actions to transform a piece of code to the target system, aiming to obtain desired functionalities by invoking a sequence of APIs with corresponding control structure.  During the process of reuse, developers often queries for a set of examples considering the task, and integrate examples that match the task and can be reused in the target context~\cite{Holmes:reuseStudy09}. Both phases can be iterative as there is no guarantee that a selected example will be appropriate until the integration results are examined. 

While many existing works focus on helping developers locate relevant source code examples~\cite{Holmes:structural05, Xie:ParseWeb07, Xsnippet:OOPSLA06, sniff:Sen09, Denys:portfolio11, Mandelin:jungloid05}, few approaches exist to support integration of source code~\cite{Cottrell:jigsaw08}. The integration phase is not trivial:  First, there exist multiple examples that provides desired functionality for the task. Recent study~\cite{Holmes:reuseStudy09} shows that it is unlikely to find a `perfect' example to provide all desired functionalities for the reuse task, and the desired functionalities might scatter in multiple examples. Even with help of code recommendation tools, developers still need to manually investigate multiple recommended code examples that are found based on the relevance to the user query rather than the ability to fit for the target context. Second, for any selected example in non-trivial system, the number of structural dependencies to follow is much too large to be completely covered by a developers~\cite{Holmes:ASE09}.  As a result, developers have to  rely on their intuition to determine which elements should be  integrated. Finally, when users try to modify the selected example to the target context, they must measure structural and semantic similarity between the example and target context~\cite{Cottrell:jigsaw08}, determine which functionality should be or can be transformed to the target, and eliminate as much irrelevant reused code as practical to save maintenance cost. %This indicates that a reuse task always requires to investigate multiple examples, resolve conflicts between different contexts, and glue functionalities together with corresponding dependent elements.  

To overcome these challenges, we propose to automatically identify common functionalities across different source code examples as well as common coupling elements that interact with common functionalities in a common way. We define coupling elements as ones that are data dependent and control dependent on the common functionalities, callers/callees of these functionalities~\cite{Robillard:FSE05},  and sibling elements that share the same callers/callees~\cite{Devanbu:randomWalk07}. Given a set of examples for a desired reuse task, our tool returns a reuse task suggestion in the format of a sequence of API calls and corresponding control structure after transforming them to fit for the target context~\cite{Cottrell:jigsaw08}. Our tool also lists a set of variants from multiple source code examples so that users can select the functions they prefer to integrate into the target context. We assume that \textit{common functionalities are the major functionalities that user intends to reuse based on the user query and their coupling elements also interact with these functionalities in a common way}.


Although some approaches advocate refactoring code rather than reuse code in this manner~\cite{fowler:refactoring}, recent researches have found that these kind of clone cannot be easily refactored~\cite{Kim:cloneGenealogy05} and have to be modified to meeting requirements in new context~\cite{Selby:largeReuse05}. Gilligan~\cite{Holmes:reuse07} and Procrustes~\cite{Holmes:ASE09} try to address the problem of example integration in the context of large-scale reuse tasks by suggesting program elements  based on structural relevance and cost of reuse. They aim to ease the process of choosing elements that are easy to reuse but developers still have to manually go through relevant elements for each example and modify them to integrate into the desired context. Jigsaw~\cite{Cottrell:jigsaw08} supports small-scale integration of source code into target system  between the example and target context. By considering structural and semantic similarity measures, it greedily matches each element between two contexts and simply copies the source element to the target if it does not correspond with any element in the target. Unfortunately, developer has to provide source and target to enable a one-to-one transformation and resolve all dependencies when pasting reused code to the target.  




% yet developers still have to manually go through all relevant elements and rely on their intuition to determine where to look.  


%balance two competing concerns: the desire to reuse as much code as possible to obtain the needed functionality of their task, and the desire to eliminate as much irrelevant reused code as practical.  save time and to increase the quality of their code


%Gilligan~\cite{Holmes:reuse07} and Procrustes~\cite{Holmes:ASE09} suggest to reuse program elements based on structural relevance and cost of reuse, yet developers still have to manually go through all relevant elements and rely on their intuition to determine where to look.  

%developers have to select the `best' example that provides desired functionality for the task and integrate well to the target context; second, even though the user is able to select the      

%Gilligan~\cite{Holmes:reuse07} and Procrustes~\cite{Holmes:ASE09} try to address this problem in the context of large-scale reuse tasks by suggesting program elements that are easy to  based on structural relevance and cost of reuse, while Jigsaw~\cite{Cottrell:jigsaw08} supports small-scale integration of source code into target system by considering structural and semantic similarity measures between the example and target context. However, in any non-trivial software system, the number of strut yet these approaches present information in terms of relevance to the user query thus the choice of examples and the order does not consider the developer's need to find an example that integrates well. The next step to identify if the problem can be This process is not trivial: first, in any non  investigate these examples to identify those that match the task and can be integrate to the target context,  developers still have to investigate relevant elements for each example manually and integrate 

%Reuse tasks can be divided into three phases: {\em location}, in which developers queries for a set of examples considering the task; {\em selection}, in which users investigate these examples to identify those that match the task and can be integrate to the target context;  and {\em integration}, in which developers copies and modifies the chosen example to fit for the target context~\cite{Holmes:reuseStudy09}. These phases can be iterative as there is no guarantee that a selected example will be appropriate until the integration results are examined. When exploring the source code they want to reuse, developers balance two competing concerns: the desire to reuse as much code as possible to obtain the needed functionality of their task, and the desire to eliminate as much irrelevant reused code as practical to save maintenance cost. an API by investigating examples of its use. perform reuse tasks to obtain the needed functionality of their task efficiently~\cite{Frakes:reuseStatus05, Parsons:cognitiveReuse04}.  integrating existing usage within target system.  



%Reuse tasks can be divided into two phases: location, in which developers queries for a set of examples considering the task; and integration, in which developers copies and modifies the chosen example to fit for the target context. Both phases can be iterative as there is no guarantee that a selected examples will be appropriate until the integration results are examined.  It is common to start a reuse task by finding relevant examples, investigating these examples to consider its relevant functionality for the task, eliminating spurious code that will increase maintenance costs, and modifying the chosen example to fit for the target context. Although some approaches advocate refactoring code rather than reuse code in this manner, recent researches have found that these kind of clone cannot be easily refactored and have to be modified to meeting requirements in new context. Numerous studies have shown the necessity of a so-called `white box' reuse that modify existing example to fit for the new context: Frake et al.\/note that most software systems are variant on existing ones and reuse strategies within companies. Serly shows that reused code analyzes 25 projects at NASA and finds that 32\% of modules within these were reused from prior projects, of these reused modules, 47\%  Parsons et al.\/present that developers always anchor their understanding to existing code and adjust code to meet their needs. locating source code examples based on user query and return When exploring the source code they want to reuse, developers balance two competing concerns: the desire to reuse as much code as possible to obtain the needed functionality of their task, and the desire to eliminate as much irrelevant reused code as practical.  save time and to increase the quality of their code. Numerous approaches exist to help developers locate source code examples, in which the developers queries for a set of examples to consider for relevance to the task; some helps developers investigates those examples. Reuse in this manner can be seen as crating code clones. While these clones have in the past been perceived negatively, recent research has found that there are a large amount of clones that are not easily refactored. non-refactorable clones 










%Software maintainers spend a lot of time trying to understand the existing software before performing the actual modification. For modification tasks such as debugging, finding and understanding program elements relevant to a bug fix tends to take more time than actually fixing the bug.  Finding related code elements  is used in a variety of software development and maintenance activities. For instance, defect prediction tools identify fault-prone elements via dependency graphs \cite{Nagappan:ICSE06, Zimmermann:ICSE08, PRMiner:FSE05}, impact analysis tools estimate potentially impacted entities by analyzing related elements of a proposed change  \cite{Denys:impactMetrics13, Orso:impactDynamic03}, API search tools identify related elements in the call graph based on user query  \cite{Denys: portfolio11, sniff:Sen09}, and feature localization tools find related elements which represent a specific concern  \cite{sniafl: TSE06, Hassan:ICSE10, Hill:locateConcern07}.  


%Numerous measures have been proposed to identify related program elements by leveraging execution trace~\cite{Briand:dynamicTSE04}, historical changes~\cite{Ying:cochangeTSE04, Gall:changeCouple08}, and lexical information in identifiers and documents~\cite{Denys:couple11, Hill:neighbor07}, yet these data may not always be available and reliable compared to source code.  A study on program investigation \cite{Robillard:TSE04} shows that effective developers tend to find related elements by following structural dependencies. However, in any non-trivial software system, the number of structural dependencies to follow is much too large to be completely covered by a developer. As a result, developers must rely on their intuition to determine where to look. Based on the hypothesis that {\em it is possible to find  related elements following program's structural dependency,}  a variety of approaches have been reported to suggest elements of potential interest via structural metrics \cite{Briand:structural99}, program slicing \cite{Bodik:slicePLSI07}, and topology-based analysis~\cite{Robillard:FSE05, Zimmermann:ICSE08}.  We observe several limitations for existing approaches: First, we find that most techniques only support a single queried elements and work at a fixed granularity in a limited scope, e.g., direct callers/callees or sibling elements that share callers/callees, but they do not have a good representation for relations in different level, such as separating overriding relations across different classes and calling relations within a single method.  Second, existing tools are sensitive to specific callers/callees but do not consider how queried elements are related with them  in a common manner, i.e., existing tools do not consider which relations are more common and should be more interesting to users. Third, existing tools assume that it takes equal effort to explore each relation, yet recent study shows that elements with many nearby dependencies require more effort for investigation~\cite{Holmes:ASE09} and hierarchical relations are easier to follow and may have a higher potential to find interesting elements than calling relations~\cite{Murphy:nlConcern11}. 

%To overcome these limitations, we propose to merge and cluster similar couplings in a layered-order given a set of program elements queried by users, and return a set of grouped elements that are relevant to the given set.  We hypothesize that when users query one or more elements, they are  interested in not only which elements are directly related to these elements, but also how these elements are coupled with other related elements in a common way, and these commonly related elements should be prioritized.  

%\input{example}
%For example, user selects two bolded methods in class \codefont{JsonWriter}:  \codefont{visit(JsonNumber)} and \codefont{visit(JsonBoolean)}. The underline elements represent methods that are invoked in queried ones: \codefont{print()} method, \codefont{JsonNumber.value}, and \codefont{JsonBoolean.value}. Suade~\cite{Robillard:FSE05}, the only approach that supports multiple elements of interest, reports these three invoked methods, as well as other 13 callers of these two methods based on class hierarchy analysis to include all methods potentially called. These results can be useful, but a) Suade fails to detect any direct relations between two queried methods and investigates direct relevant elements for them separately, and report invoked methods (\codefont{JsonNumber.value()} and \codefont{JsonBoolean.value()}) and callers (\codefont{JsonNumber.visit()} and \codefont{JsonBoolean.visit()}) separately; b) the results are sensitive to the callers of queried elements (\codefont{JsonNumberOp- tional.recordOptional()}, \codefont{JsonFormatNumberHandler.print Number()}, \codefont{JSON.write()}, and the rest 10 callers). I hypothesize that relevant elements that users are interested in should be \codefont{<JsonValue>.visit()} and \codefont{JSON.write()} as callers, and \codefont{<JsonValue>.value()}  and \codefont{print()} as methods invoked by queried elements. 


%We state our research question as: {\em Given a set of program elements defined by users, which elements are related to the set of interest with respect to a relation vocabulary?}
% and code reuse \cite{Holmes:ASE09, Holmes:structural05}
%\input{table}
%\section{Related Work}


%Most measures for related element identification are {\em structural} by following method call chains, control flow, and variable def-use. These works leverage coupling metrics~\cite{Briand:structural99}, program slicing \cite{Bodik:slicePLSI07}, and topology-based search~\cite{Robillard:FSE05, Zimmermann:ICSE08}. 


%\noindent{\bf{Static Metrics.}} Briand et al.\/ propose a set of structural coupling metrics to measure coupling between two classes. such as Coupling Between Objects (CBO) and Response for a Class (RFC). A set of metrics are proposed to predict defects based on the complexity or defect history~\cite{Gyimothy:metrics05, Nagappan:ICSE06}. Yet static metrics are usually too coarse-grained that limits their usefulness to recommend code of immediate interest.

%\noindent{\bf{Program slicing.}} Weiser~\cite{Weiser:slice84} proposes to identify  a part of program that may affect the values computed at some point of interest. Thin slicing~\cite{Bodik:slicePLSI07} only consists of producer statements for the seed and hierarchically expanded to include statements explaining how producers affect the seed. Yet computing slicing can be expensive and slices are often too large to be useful for users. 


%\noindent{\bf{Topology-based analysis.}} Suade algorithm \cite{Robillard:FSE05}  ranks elements based on the closeness of their structural association with program elements in a set of interest. It only returns elements that are directly related to the set of interest. FRAN~\cite{Devanbu:randomWalk07} extends Suade by considering the sibling elements that share common caller or callee with queried elements. FRAN focuses on calling relation in C given a single queried function. Zimmermann and Nagappan \cite{Zimmermann:ICSE08} use network analysis to identify  {\em central binaries} based on dependency graph, aiming to predict fault-prone modules based on defect history. Other usage of identifying related elements rely on calling graphs with class hierarchy analysis for dynamic binding \cite{PRMiner:FSE05, Orso:impactDynamic03, Murphy:nlConcern11}. However, none of them groups relations in different granularities and identifies commonly used relations in layered-order. 
 
%Considering that structural coupling often results in a large number of relationships within a limited scope, researchers have proposed other alternative measures to identify related elements.

%Briand et al.~\cite{Briand:dynamicTSE04} handle dynamic binding in object-oriented programs by analyzing of the execution of a program. Dynamic slicing is a variant of slicing that select related code piece considering program execution trace \cite{Agrawal:dynamicSlice90}. Specifically, dynamic slicing only considers program dependencies that occur in a specific execution of the program. In contrast to static approaches, dynamic measures relies on the availability and quality of test cases for an executable program, thus they cannot be applied to incomplete code or code that cannot be executed. 

 %Ying et al.\cite{Ying:cochangeTSE04} report elements that are often changed together during program evolution tasks at the file level, Fluri et al.\/ identify frequently co-changed files and filter co-changed methods that result from structural changes \cite{Gall:changeCouple05}. However, reliance on change history implies that the approach cannot be used when queried elements are never changed before. 


%Revelle et al.~\cite{Denys:couple11} exploit relations captured from the source code lexicon using Information Retrieval techniques and propose a set of semantic metrics to define a coupling between classes based on textural information from code and comments. Hill et al.~\cite{Hill:neighbor07} use lexical information to identify related methods  corresponding to queried ones and expand call chains to find relevant elements missed by lexical search.  The main tradeoff for these measures is that they assume that similar terms always indicate related functionality.  

%In summary, these alternative measures  aim to capture relations that are missed by existing structural coupling by leveraging revision history, lexical information, and execution traces. Our approach aims to extend the structural measures to group relations in different granularities and identify commonly used relations based on available and reliable structural dependency.  



%\bibliographystyle{abbrvnat}
% \renewcommand{\bibfont}{\footnotesize} % <--- change bib font size here
% \setlength{\bibsep}{0.5ex}             % <--- change space between bib entries here
\bibliographystyle{abbrv}
\bibliography{coupling,reuse} 
%\bibliography{strings-short,paper}  % <--- use short strings in case of emergency

\end{document}
