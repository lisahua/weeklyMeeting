

%\input{dataset_table}
\section{Approach}



%The Resource Description Framework (RDF) [26] is the data-model for representing meta-data in the Semantic Web. The RDF data-model formalizes meta-data based on subject ? predicate ? object triples, so called RDF statements. 

\subsection{Evaluation Dataset} 

We collect K defects from student-written versions of Java Program with intricate faults in nested loops and recursive data structure. This section discusses how we construct the dataset, the subjects used in the experiment, and how we categorize the defects. 


\noindent{\textbf{Methodology.  }}We collect K defects from high-level Data Structure course with an enrollment of 99 students (EE 422C, at UT Austin). For each of the 19 pop quizzes, students are given a specification and two JUnit test cases that their program should pass and they need to write a Java program that satisfies the specification and passes test cases in half an hour.  The pop quizzes covers the topic described last week and students have one week to review the concept before the pop quizzes. During the quiz, students  are not allowed to use the Internet or any Integrated Development Environment. They need to write down code in paper based on the given material. The defects are collected and manually classified based on program equivalence. We manually isolate the defects such that each defect is different from correct program only with a range of input for a specific field. 
 We discard the defects that occur only once to eliminate random error. We then input these defects and test them against corresponding test suite generated by Korat, a symbolic execution tool that automatically generates all test cases within a given bound. Korat generates M test cases in total for 18 problems. 

\noindent{\textbf{Subjects.  }} The dataset consists of  four basic data structures and three sorting algorithms.  
\begin{enumerate}
\item BST: Binary Search Tree  is a special binary tree that the key in each node must be greater than all keys stored in the left sub-tree, and smaller than all keys in right sub-tree. We check insert operation and three traversal approaches: in-order, pre-order, and post-order. Our test suite covers all test cases up to seven nodes, which leads to all cases in binary search tree up to three layers.  
\item LL: Sorted Linked List  is a linear collection of data elements in ascendent order in which  nodes can point to the next node by means of a pointer. 
%Our specification defines a sentinel header for the linked list whose next field points to itself for an empty linked list. If the linked list is not empty, the next field for the last element will point to the header.  
Students are asked to finish insert and reverse operations as well as a method that validates whether the list has loop or not.  Our test suite covers all test cases up to three nodes.  
\item DLL: Doubly Linked List  is a linked data structure which consists of a set of sequentially linked nodes. Each node has next and previous field, pointing to its next node and previous node correspondingly. We adapt the implementation of \codefont{java.util.PriorityQueue} in \codefont{openjdk version 6-27}. 
%The list consists of a sentinel header. If the list is empty, both the header's next field and previous field point to header itself. Otherwise, the header's previous field points to the last elements in the list, and this last elements' next field points to the header.  
Our test suite covers all test cases up to three nodes.  

\item Heap: MinHeap is a specialized tree-based data structure whose parent node is always smaller than its children. Students are required to finish insert and remove operations. They are also required to implement sorting algorithm to convert an unsorted array to a MinHeap. Our test suite covers all test cases up to seven nodes.

\item Sorting: We check three sorting algorithms: Bubble Sort, Quick Sort, and Merge Sort. Bubble Sort requires two loops while Quick Sort and Merge Sort requires recursive structure. We verify the program with up to five numbers.  

\end{enumerate}

\noindent{\textbf{Categorization.  }}  We categorize the defects into omission error (should assign a value but miss the assignment) and commission error (assign a value but assign another value). We further classify these errors into method-level and path-level  with respect to \todo{.... If a field value should be changed but is not changed by applying a method, we regard it as a method-level omission error. Similarly, if a field value should be changed but is not changed within a given block, but it is correctly set for all the inputs that do not execute that block, we regard it as block-level omission error. }



\subsection{Comparison with other Program Repair Tools}  

We manually convert defects to C and compare our efficacy with three existing program repair tools: GenProg, SPR, and Angelix. 

\begin{table*}[ht]
\begin{center}
\caption{Evaluation Dataset }
\label{tab:evalSubject}
\vspace{1mm}
\scriptsize{
\begin{tabular*}{1\textwidth}{@{}c|r|cc|cccc|cccc|cccc@{}} 
&Subject		&LOC	&\# tests 	&\#bug	& ratio	&\tool&G/S/A	&\#Omission & ratio	&\tool&G/S/A	&\#Omission & ratio	&\tool&G/S/A		 \\\midrule
%1&BST.insert	&31		&		& 		&		&		&2		&BST.post		&37		&		&		&\\ 
%3&BST.in		&20		&  		&		&		&		&4		&BST.pre		&21		&		&		&\\
% 5&LL.insert	&		&		&		&		&		&6		&LL.remove 	&		&		&		& \\ 
%7&LL.reverse	&		&		& 		&		&		&8		&LL.hasLoop	&		&		&		& \\ 
%9&DLL.hasLoop&		&		&		&		&		&10		& DLL.remove	&		&		&		& \\ 
%11&DLL.addFirst&		&		&		&		&		&12		& DLL.addLast	&		&		&		& \\ 
%13&Heap.insert	&		&		&		&		&		&14		&Heap.remove	&		&		&		& \\ 
%15&Heap.sort	&		&		&		&		&		&16		&Sort.bubble	&		&		&		& \\ 
%17&Sort.merge&		&		&		&		&		& 18		&Sort.quick	&		&		&		& \\ 
\end{tabular*}
 \label{tab:dataset}
}
 \end{center}
\end{table*}