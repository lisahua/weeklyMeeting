
\section{Problem Statement}

Developers frequently use source code examples as the basis for interacting with an  application programming interface (API) to obtain the needed functionality.  In this case, the source code example serves as the explicit origin for a reuse task when it fits a developer's context sufficiently well~\cite{Frakes:reuseStatus05, Parsons:cognitiveReuse04}. We define a reuse task as a series of copy-paste-modify actions to transform a piece of code to the target system, aiming to obtain desired functionalities by invoking a sequence of APIs with corresponding control structure.  During the process of reuse, developers often query for a set of examples considering the task, and integrate examples that match the task  into the target context~\cite{Holmes:reuseStudy09}. The location and integration phase can be iterative as there is no guarantee that a selected example will be appropriate until the integration results are examined. 

While many existing works focus on helping developers locate related source code examples~\cite{Holmes:structural05, Xie:ParseWeb07, Xsnippet:OOPSLA06, sniff:Sen09, Denys:portfolio11, Mandelin:jungloid05}, few approaches exist to support integration of source code~\cite{Cottrell:jigsaw08}. The integration phase is not trivial:  First, there exist multiple examples that provide desired features for the task. Recent study~\cite{Holmes:reuseStudy09} shows that it is unlikely to find a `perfect' example that provides all desired features for the reuse task, and the desired features are always scattered in different example variants. Thus even with the help of code recommendation tools, developers still need to manually investigate multiple recommended code examples that are found based on the relevance to the user query rather than the ability to fit for the target context, in order to find the common API calls that provide expected features. Second, for any selected example in non-trivial system, the number of structural dependencies to follow is much too large to be completely covered by a developers~\cite{Holmes:ASE09}.  As a result, developers have to  rely on their intuition to determine which elements should be  integrated. Finally, when users try to modify the selected example to the target context, they should not only  measure structural and semantic similarity between the example and target context for the main API calls that provide desired features~\cite{Cottrell:jigsaw08}, but also determine which related elements should be transformed to the target, and eliminate  unrelated code  to save maintenance cost. %This indicates that a reuse task always requires to investigate multiple examples, resolve conflicts between different contexts, and glue functionalities together with corresponding dependent elements.  

To overcome these challenges, we propose to automatically identify common API calls across different source code examples as well as common coupling elements that interact with common functionalities in a common way. We define coupling elements as ones that are data dependent and control dependent on the common functionalities, callers/callees of these functionalities~\cite{Robillard:FSE05},  and sibling elements that share the same callers/callees~\cite{Devanbu:randomWalk07}.  We assume that \textit{common API calls are the major features that user intends to reuse based on the user query and the coupling elements of these functionalities should also be investigated if they interact with these APIs in a common way}. Given a set of examples for a desired reuse task, our tool returns a reuse task suggestion in the format of a sequence of API calls and corresponding control structure which have been transformed to fit for the target context~\cite{Cottrell:jigsaw08}. Our tool also lists a set of variants from multiple source code examples for users to select the features they prefer to integrate into the target context, and automatically transforms chosen examples to the target context.

Although some approaches advocate refactoring code rather than reuse code~\cite{fowler:refactoring}, recent researches have found that these kind of `clone' cannot be easily refactored~\cite{Kim:cloneGenealogy05} and have to be modified to meeting requirements in new context~\cite{Selby:largeReuse05}. Gilligan~\cite{Holmes:reuse07} and Procrustes~\cite{Holmes:ASE09} try to address the problem of source code integration in the context of large-scale reuse tasks by suggesting program elements that are easy to reuse based on structural relevance and cost of reuse in the source context, but developers still have to manually go through related elements for each example and modify them to integrate into the desired context. Jigsaw~\cite{Cottrell:jigsaw08} supports small-scale integration of source code into target system  between the example and target context. By considering structural and semantic similarity measures, it greedily matches each element between two contexts and simply copies the source element to the target if it does not correspond with any element in the target. Unfortunately, developer has to provide source and target to enable a one-to-one transformation and resolve all dependencies when pasting reused code to the target.  Our approach overcomes these two limitations: we extract common functionalities from multiple examples and identify how the related elements interact with main API calls in a common way.


