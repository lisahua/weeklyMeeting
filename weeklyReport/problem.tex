
\section{Problem Statement}

Developers frequently use source code examples as the basis for interacting with an  application programming interface (API) to obtain the needed functionality~\cite{CodeSearch:FSE15}.  In this case, the source code example serves as the explicit origin for a reuse task which transforms a sequence of APIs with corresponding control structure to the target context~\cite{Frakes:reuseStatus05}.  During the process of reuse task such as `add undo and redo actions in my Graphics Editor', developers often query for a set of examples considering the task, and integrate examples that match the task into their system~\cite{Parsons:cognitiveReuse04}. 

Both location and integration of reusable examples are not trivial. First, for the phase of location, existing tools that search for specific API usage examples~\cite{MAPO:ECOOP09, Buse:apiICSE12, Export:DenysASE13, Sourcerer:SC14} might not be able to support such reuse tasks that always involve in multiple classes and related methods.  As a result, developers always query general search engine like Google or expert sites like StackOverflow to investigate potential tutorials for desired features. These search engines will return a list of informal documentations and users have to search for source code elements in these resources. Although some linking recovery  tools~\cite{PeterACE:ICSE13, RecoDoc:ICSE12} can help identify a partial program in the form of code snippet, they are not  sufficient to create a pragmatic reuse plan as the main functionality is always interleaving with auxiliary ones and  it is unlikely to find a `perfect' example that provides all desired features for the reuse task~\cite{Holmes:reuseStudy09}. Considering that a single example is not enough for a given task, developers need to investigate multiple example variants manually for the desired features (i.e., common API calls). Moreover, for the phase of integration, developers should not only  measure structural and semantic similarity between the example and target context for the main API calls that provide desired features~\cite{Cottrell:jigsaw08}, but also determine which unnecessary code should be eliminated to save maintenance cost~\cite{Holmes:ASE09, Holmes:reuse07} and which related elements should be transformed with structural correspondence~\cite{Cottrell:generalize07} to the target context. Unfortunately, for any selected example in non-trivial system, the number of structural dependencies to follow is much too large to be completely covered by developers. The partial programs~\cite{partialProgram:OOPSLA08} extracted from the location phase make it even harder to  tease out irrelevant elements  without knowing a full scenario of precise type information and method implementation details.  Finally, the location and integration phase can be iterative as there is no guarantee that a selected example will be appropriate until the integration results are examined. 

To overcome these challenges, we propose to automatically identify common API calls that provide the main feature across different partial program examples from informal documentation, and integrate this reusable example to the target context with a set of related elements that are necessary to implement the main feature. We assume that the maximum set of overlapping API calls are the salient features that user intends to reuse based on the user query and the elements that are data dependent and control dependent on the common functionalities should interact with these APIs in a common way across different examples. Given a free-form query from users, our tool invokes search engine (e.g., Google) to obtain a list of partial programs by recovering links between code elements and informal resources, clusters these examples and extracts common API calls with corresponding control structures for each cluster, and integrate the user-chosen reuse plan to the target context with related elements that are dependent on the salient code elements. Our tool also lists a set of variants from multiple source code examples so that users can select features they prefer to reuse, and transforms chosen features to the target context. 

Our approach helps identify and integrate reusable examples in three phases:
\begin{itemize}
\item \textbf{Example Collection Phase.} We identify the main features from multiple partial programs derived from informal resources. Without confined to an established code corpus to search for code examples, we leverage web search engine to obtain a list of tutorials in the form of partial programs~\cite{PeterACE:ICSE13, RecoDoc:ICSE12}. We use partial program analysis~\cite{partialProgram:OOPSLA08} to infer partial type and resolve syntactic ambiguity. 

\item \textbf{Example Clustering Phase.} We cluster similar code examples together to reduce the duplicated code snippets . For each cluster, based on the partial type facts extracted in example collection phase,  we first identifying structural correspondence for the portions that are identical, similar but not identical, and different without correspondence~\cite{Cottrell:generalize07}. We then extract both identical and similar portions as common features, and regard the rest as alternative ones. 

\item \textbf{Example Integration Phase.} Our approach investigates the user's contexts to recommend the best-fit example considering both structural and lexical similarity~\cite{Holmes:reuseStudy09}. After user's confirmation or user's selection, our approach integrates each structural correspondence to the target context~\cite{Cottrell:jigsaw08} with corresponding related elements. 
\end{itemize}

 \begin{figure*}[!htb]
    \centering
\includegraphics[width=1\textwidth]{fig/system.pdf}
       \caption{System process overview}
        \label{fig:system}
   \end{figure*}


