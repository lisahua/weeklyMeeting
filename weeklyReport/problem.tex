
\section{Problem Statement}

Developers frequently use source code examples as the basis for interacting with an  application programming interface (API) to obtain the needed functionality~\cite{CodeSearch:FSE15}.  In this case, the source code example serves as the explicit origin for a reuse task which transforms a sequence of APIs with corresponding control structure to the target context~\cite{Frakes:reuseStatus05}.  During the process of reuse task such as `add undo and redo actions in my Graphics Editor', developers often query for a set of examples considering the task, and integrate examples that match the task into their system~\cite{Parsons:cognitiveReuse04}. 

Both location and integration of reusable examples are not trivial. For the phase of location, existing tools that search for specific API usage examples~\cite{MAPO:ECOOP09, Buse:apiICSE12, Export:DenysASE13, Sourcerer:SC14} might not be able to support such reuse tasks that always involve in multiple classes and related methods.  As a result, developers always query general search engines like Google or expert sites like StackOverflow to investigate potential tutorials for desired features. These search engines will return a list of informal documentations and users have to search for source code elements in these resources. Although some linking recovery  tools~\cite{PeterACE:ICSE13, RecoDoc:ICSE12} can help identify a partial program in the form of code snippet, they are not  sufficient to create a pragmatic reuse plan as the main functionality is always interleaving with auxiliary ones and  it is unlikely to find a `perfect' example that provides all desired features for the reuse task~\cite{Holmes:reuseStudy09}. Considering that a single example is not enough for a given task, developers need to investigate multiple example variants manually for the desired features (i.e., common API calls). For the phase of integration, developers should not only  measure structural and semantic similarity between the example and target context for the main API calls that provide desired features~\cite{Cottrell:jigsaw08}, but also determine which unnecessary code should be eliminated to save maintenance cost~\cite{Holmes:ASE09, Holmes:reuse07} and which related elements should be transformed with structural correspondence~\cite{Cottrell:generalize07} to the target context. Unfortunately, for any selected example in non-trivial system, the number of structural dependencies to follow is much too large to be completely covered by developers. The partial programs~\cite{partialProgram:OOPSLA08} extracted from the location phase make it even harder to  tease out irrelevant elements  without knowing a full scenario of precise type information and method implementation details.  Moreover,  the location and integration phase can be iterative as there is no guarantee that a selected example will be appropriate until the integration results are examined~\cite{Holmes:reuseStudy09}. 

To overcome these challenges, we propose to automatically identify common API calls that provide the main feature across different partial program examples from informal documentation, and integrate this reusable example to the target context with a set of related elements that are necessary to implement the main feature. We assume that the overlapping API calls are the main features that the user intends to reuse based on the user query, and the related elements should be transformed to the target together with main features if they are data dependent and control dependent on the common functionalities in a common way across different examples. 
Figure~\ref{fig:system} illustrates the process of our system. 
Given a free-form query from users, our tool invokes search engine (e.g., Google) to obtain a list of partial programs by recovering links between code elements and informal resources, clusters these examples and extracts common structural facts (e.g., jQuery logical facts) with corresponding control structures for each cluster, identifies a set of related elements that interact with main elements in a common way,  constructs reuse task with both main elements and related elements and ranks them based on user's context, and finally integrates the reuse task selected by users to the target context. 

%Our tool also lists a set of variants from multiple source code examples so that users can select features they prefer to reuse, and transforms chosen features to the target context. 

Our approach helps identify and integrate reusable examples in three phases:
\begin{itemize}
\item \textbf{Example Collection Phase.} We identify the main features from multiple partial programs derived from informal resources. Without confined to an established code corpus, we leverage web search engine to obtain a list of code examples in the form of partial programs~\cite{PeterACE:ICSE13, RecoDoc:ICSE12}. We use partial program analysis~\cite{partialProgram:OOPSLA08} to infer partial type and resolve syntactic ambiguity. 

\item \textbf{Example Clustering Phase.} We take three steps in this phase. Based on the type facts extracted from partial program analysis, we first cluster similar code examples based on the number of shared class-level facts to reduce the duplicated code snippets. Next, for each example in each cluster, we identify main facts that are shared among all examples, and perform slicing to identify related elements. We ignore the specific related elements that appear in a single example. Finally, we group the related elements based on their common interaction with main elements.

\item \textbf{Example Integration Phase.} Our approach investigates the user's contexts to recommend the best-fit reuse task  considering the number of matched structural facts in target context. After user's selection, our approach integrates the reuse task to the target context by transforming the unmatched structural facts based on matched facts in the context. 
\end{itemize}

 \begin{figure*}[!htb]
    \centering
\includegraphics[width=1\textwidth]{fig/system.pdf}
       \caption{System process overview}
        \label{fig:system}
   \end{figure*}


