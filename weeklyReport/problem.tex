
\section{Last week}

Based on our discussion last week, our problem statement includes:

\begin{enumerate}
\item Developers do not know the name of API elements a priori, though locating code example through existing search engine often expects the developers to know API elements' names.
\item Reuse tasks involve multiple related classes and methods, rather than a single method/class. Yet code search engines do not help developers recognize the latent structure among related classes/methods. (at the granularity of multiple methods)
\item During copy/paste based reuse, developers must remove irrelevant parts. Our hypothesis is that having multiple examples of the same kind will help winnow out irrelevant parts. (at the granularity of multiple examples)
\end{enumerate}

We have three hypotheses correspondingly:
\begin{enumerate}
\item We believe that NLP text with partial code snippet could help us identify the name of API elements based on keywords from free-form query. 

\item Our hypothesis is that we can find related elements by following the structural dependencies of seed API elements in code and by ranking other API elements potentially mentioned in natural language text. 

\item We believe that clustering multiple examples of the same kind and finding the commonality may help remove irrelevant parts. 

\end{enumerate}

I focus on the second  problem, and perform a preliminary study using popular code search engines to illustrate this problem. 

\input{example}
\input{eval-table}
\section{Problem 2}
Problem: Reuse tasks involve multiple related classes and methods, yet code search engines do not help developers recognize the latent structure among related classes/methods.

Hypothesis: We can find and rank related elements by following the structural dependencies of seed API elements in code. 

Input: a free-form query that user provides to present her reuse intention.

Output: a list of classes/methods implementation that complete this reuse task.

Sub questions: Do reuse tasks involve multiple related classes and methods? Can existing tools find reusable examples that involve multiple related classes and methods?



To answer these two subquestions, I search for the evaluation dataset for existing feature location/concern mining tools~\cite{Denys:FCA12, Hill:FindConcept07, Hassan:concernHistory10, Breu:DynamicAspect04} shown in Table~\ref{tab:concern},    reuse tools~\cite{Holmes:reuse07, Holmes:ASE09} shown in Table~\ref{tab:reuse}, and code search tools using free-form query ~\cite{sniff:Sen09, Portfolio:DenysICSE11, Sourcerer:SC14, Gvero:ICSE15, spotWork:ICSE14} shown in Table~\ref{tab:freeform}. We find that most medium-scale or large-scale reuse tasks involve multiple methods and classes,  and the developer should implement multiple methods and classes to finish the reuse task. Existing  code completion tools can complete a single method which involves in multiple API calls, yet they assume that all related APIs or  objects used in their suggested code snippet already exist. We argue that this assumption might not hold for a non-trivial reuse task, because developers need to implement the salient API calls that provide the main functionality as well as other related elements based on the latent structure.  

% existing code search tools and  feature location tools  do not help developers recognize the latent structure among related classes/methods. 

%Other code search engines such as Koders~\cite{Koders}, Krugle~\cite{Krugle}, and SearchCode~\cite{SearchCode} are available on the web, %which can be used to assist programmers by providing relevant code examples with usages of the given free-form query from a large number of public source code repositories. 
%yet the results are sorted based on the text matching and they also fail to recognize the latent structure among related classes/methods. 

%Based on Table~\ref{tab:concern} and Table~\ref{tab:reuse}, most medium-scale or large-scale reuse tasks involve multiple methods and classes.  However, existing code search tools and  feature location tools  do not help developers recognize the latent structure among related classes/methods. We do not focus on large-scale reuse task mentioned in~\cite{Holmes:reuse07, Holmes:ASE09}. 


%In summary,  a feature/concern reuse task involves multiple related classes and methods. The developer should implement multiple methods and classes to finish the reuse task. Existing  code completion tools can complete a single method which involves in multiple API calls, yet they assume that all related APIs or  objects used in their suggested code already exist. We argue that it requires multiple methods to implement a non-trivial feature/concern. 




%\subsection{Problem 3}
%Problem: During copy/paste based reuse, developers must remove irrelevant parts and find salient API elements based on the context. 

%Hypothesis: Our hypothesis is that having multiple examples of the same kind will help winnow out irrelevant parts, i.e, clustering multiple examples of the same kind and finding the commonality may help remove irrelevant parts. 

%We use the results for  the last three concerns implementation in Table~\ref{tab:concern} found by the code search engine SearchCode to illustrate the Problem 3. 





\begin{comment}
Developers frequently use source code examples as the basis for interacting with an  application programming interface (API) to obtain the needed functionality~\cite{CodeSearch:FSE15}.  In this case, the source code example serves as the explicit origin for a reuse task which transforms a sequence of APIs with corresponding control structure to the target context~\cite{Frakes:reuseStatus05}.  During the process of reuse task such as `add undo and redo actions in my Graphics Editor', developers often query for a set of examples considering the task, and integrate examples that match the task into their system~\cite{Parsons:cognitiveReuse04}. 

Both location and integration of reusable examples are not trivial. For the phase of location, existing tools that search for specific API usage examples~\cite{MAPO:ECOOP09, Buse:apiICSE12, Export:DenysASE13, Sourcerer:SC14} might not be able to support such reuse tasks that always involve in multiple classes and related methods.  As a result, developers always query general search engines like Google or expert sites like StackOverflow to investigate potential tutorials for desired features. These search engines will return a list of informal documentations and users have to search for source code elements in these resources. Although some linking recovery  tools~\cite{PeterACE:ICSE13, RecoDoc:ICSE12} can help identify a partial program in the form of code snippet, they are not  sufficient to create a pragmatic reuse plan as the main functionality is always interleaving with auxiliary ones and  it is unlikely to find a `perfect' example that provides all desired features for the reuse task~\cite{Holmes:reuseStudy09}. Considering that a single example is not enough for a given task, developers need to investigate multiple example variants manually for the desired features (i.e., common API calls). For the phase of integration, developers should not only  measure structural and semantic similarity between the example and target context for the main API calls that provide desired features~\cite{Cottrell:jigsaw08}, but also determine which unnecessary code should be eliminated to save maintenance cost~\cite{Holmes:ASE09, Holmes:reuse07} and which related elements should be transformed with structural correspondence~\cite{Cottrell:generalize07} to the target context. Unfortunately, for any selected example in non-trivial system, the number of structural dependencies to follow is much too large to be completely covered by developers. The partial programs~\cite{partialProgram:OOPSLA08} extracted from the location phase make it even harder to  tease out irrelevant elements  without knowing a full scenario of precise type information and method implementation details.  Moreover,  the location and integration phase can be iterative as there is no guarantee that a selected example will be appropriate until the integration results are examined~\cite{Holmes:reuseStudy09}. 

To overcome these challenges, we propose to automatically identify common API calls that provide the main feature across different partial program examples from informal documentation, and integrate this reusable example to the target context with a set of related elements that are necessary to implement the main feature. We assume that the overlapping API calls are the main features that the user intends to reuse based on the user query, and the related elements should be transformed to the target together with main features if they are data dependent and control dependent on the common functionalities in a common way across different examples. 
Figure~\ref{fig:system} illustrates the process of our system. 
Given a free-form query from users, our tool invokes search engine (e.g., Google) to obtain a list of partial programs by recovering links between code elements and informal resources, clusters these examples and extracts common structural facts (e.g., jQuery logical facts) with corresponding control structures for each cluster, identifies a set of related elements that interact with main elements in a common way,  constructs reuse task with both main elements and related elements and ranks them based on user's context, and finally integrates the reuse task selected by users to the target context. 

%Our tool also lists a set of variants from multiple source code examples so that users can select features they prefer to reuse, and transforms chosen features to the target context. 

Our approach helps identify and integrate reusable examples in three phases:
\begin{itemize}
\item \textbf{Example Collection Phase.} We identify the main features from multiple partial programs derived from informal resources. Without confined to an established code corpus, we leverage web search engine to obtain a list of code examples in the form of partial programs~\cite{PeterACE:ICSE13, RecoDoc:ICSE12}. We use partial program analysis~\cite{partialProgram:OOPSLA08} to infer partial type and resolve syntactic ambiguity. 

\item \textbf{Example Clustering Phase.} We take three steps in this phase. Based on the type facts extracted from partial program analysis, we first cluster similar code examples based on the number of shared class-level facts to reduce the duplicated code snippets. Next, for each example in each cluster, we identify main facts that are shared among all examples, and perform slicing to identify related elements. We ignore the specific related elements that appear in a single example. Finally, we group the related elements based on their common interaction with main elements.

\item \textbf{Example Integration Phase.} Our approach investigates the user's contexts to recommend the best-fit reuse task  considering the number of matched structural facts in target context. After user's selection, our approach integrates the reuse task to the target context by transforming the unmatched structural facts based on matched facts in the context. 
\end{itemize}

 \begin{figure*}[!htb]
    \centering
\includegraphics[width=1\textwidth]{fig/system.pdf}
       \caption{System process overview}
        \label{fig:system}
   \end{figure*}
\end{comment}

