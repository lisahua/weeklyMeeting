\section{Problem Statement}

%\section{Problem 1}  
\noindent{\bf{Proactively Recommending Code Examples to Reduce Integration Conflicts}}



%Problem: The code examples returned from code search engine or other code search tools are not structured. 

%Reuse tasks involve multiple related classes and methods, yet code search engines do not help developers recognize the latent structure among related classes/methods.

%Hypothesis: We can find and rank related elements by following the structural dependencies of seed API elements in code. 

%Input: a set of code examples returned from code search engine.

%Output: a list of code example clusters based on their structural similarity. 

%Sub questions: Do reuse tasks involve multiple related classes and methods? Can existing tools find reusable examples that involve multiple related classes and methods?



%To answer these two subquestions, I search for the evaluation dataset for existing feature location/concern mining tools~\cite{Denys:FCA12, Hill:FindConcept07, Hassan:concernHistory10, Breu:DynamicAspect04} shown in Table~\ref{tab:concern},    reuse tools~\cite{Holmes:reuse07, Holmes:ASE09} shown in Table~\ref{tab:reuse}, and code search tools using free-form query ~\cite{sniff:Sen09, Portfolio:DenysICSE11, Sourcerer:SC14, Gvero:ICSE15, spotWork:ICSE14} shown in Table~\ref{tab:freeform}. We find that most medium-scale or large-scale reuse tasks involve multiple methods and classes,  and the developer should implement multiple methods and classes to finish the reuse task. Existing  code completion tools can complete a single method which involves in multiple API calls, yet they assume that all related APIs or  objects used in their suggested code snippet already exist. We argue that this assumption might not hold for a non-trivial reuse task, because developers need to implement the salient API calls that provide the main functionality as well as other related elements based on the latent structure.  



Developers frequently use source code examples as the basis for interacting with an  application programming interface (API) to obtain the needed functionality~\cite{CodeSearch:FSE15}.  In this case, the source code example serves as the explicit origin for a reuse task which transforms a sequence of APIs with corresponding control structure to the target context~\cite{Frakes:reuseStatus05}.  

%During the process of reuse task such as `add undo and redo actions in my Graphics Editor', developers often query for a set of examples considering the task, and integrate examples that match the task into their system~\cite{Parsons:cognitiveReuse04}. 

%Both location and integration of reusable examples are not trivial. For the phase of location, existing tools that search for specific API usage examples~\cite{MAPO:ECOOP09, Buse:apiICSE12, Export:DenysASE13, Sourcerer:SC14} might not be able to support such reuse tasks that always involve in multiple classes and related methods.  As a result, developers always query general search engines like Google or expert sites like StackOverflow to investigate potential tutorials for desired features. These search engines will return a list of informal documentations and users have to search for source code elements in these resources. Although some linking recovery  tools~\cite{PeterACE:ICSE13, RecoDoc:ICSE12} can help identify a partial program in the form of code snippet, they are not  sufficient to create a pragmatic reuse plan as the main functionality is always interleaving with auxiliary ones and  it is unlikely to find a `perfect' example that provides all desired features for the reuse task~\cite{Holmes:reuseStudy09}. Considering that a single example is not enough for a given task, developers need to investigate multiple example variants manually for the desired features (i.e., common API calls). For the phase of integration, developers should not only  measure structural and semantic similarity between the example and target context for the main API calls that provide desired features~\cite{Cottrell:jigsaw08}, but also determine which unnecessary code should be eliminated to save maintenance cost~\cite{Holmes:ASE09, Holmes:reuse07} and which related elements should be transformed with structural correspondence~\cite{Cottrell:generalize07} to the target context. Unfortunately, for any selected example in non-trivial system, the number of structural dependencies to follow is much too large to be completely covered by developers. The partial programs~\cite{partialProgram:OOPSLA08} extracted from the location phase make it even harder to  tease out irrelevant elements  without knowing a full scenario of precise type information and method implementation details.  Moreover,  the location and integration phase can be iterative as there is no guarantee that a selected example will be appropriate until the integration results are examined~\cite{Holmes:reuseStudy09}. 

%To overcome these challenges, we propose to automatically identify common API calls that provide the main feature across different partial program examples from informal documentation, and integrate this reusable example to the target context with a set of related elements that are necessary to implement the main feature. We assume that the overlapping API calls are the main features that the user intends to reuse based on the user query, and the related elements should be transformed to the target together with main features if they are data dependent and control dependent on the common functionalities in a common way across different examples.  Figure~\ref{fig:system} illustrates the process of our system.  Given a free-form query from users, our tool invokes code search engine  to obtain a list of partial programs by recovering links between code elements and informal resources, clusters these examples and extracts common structural facts (e.g., jQuery logical facts) with corresponding control structures for each cluster, identifies a set of related elements that interact with main elements in a common way,  constructs reuse task with both main elements and related elements and ranks them based on user's context, and finally integrates the reuse task selected by users to the target context. 

%Our tool also lists a set of variants from multiple source code examples so that users can select features they prefer to reuse, and transforms chosen features to the target context. 

\noindent{\bf{Identify Duplicated Feature Requests}}

%\item \textbf{Example Integration Phase.} Our approach investigates the user's contexts to recommend the best-fit reuse task  considering the number of matched structural facts in target context. After user's selection, our approach integrates the reuse task to the target context by transforming the unmatched structural facts based on matched facts in the context. 

% \begin{figure*}[!htb]
%    \centering
%\includegraphics[width=1\textwidth]{fig/system.pdf}
%       \caption{System process overview}
%        \label{fig:system}
%   \end{figure*}


