
%\section{Motivating Example}










\begin{comment}
\noindent{\textbf{Example collection phase.}} With 7  partial programs at hand, it first extracts class-level structural facts for each code example. Based on a relative match threshold to measure the relative occurrence of the number of matched facts out of all class-level facts,  our tool clusters these examples in three groups using complete linkage technique: 5 examples use classes in Java Swing like `AbstractAction' and `UndoableEditListener', another example uses a `Node' data structure to illustrate how to implement undo/redo actions using command design pattern, and the last example is the javadoc for `UndoManager'.  Our tool starts from the first cluster as it has the highest relative occurrence out of all examples. Based on partial program analysis, we generate a list of type facts to infer types and bind methods.

The common facts our tool extracts include: 
\begin{table}[ht]
\begin{center}
\caption{Common Structural Facts Extracted from the Examples }
\label{tab:total}
\vspace{1mm}
\scriptsize{
\begin{tabular*}{0.5\textwidth}{@{}l|l@{}} \hline
Level&Structural Facts\\\hline
class&subType(Undo*Action, AbstractAction), \\ 
&subType(Redo*Action, AbstractAction), \\
&subType(*Listener, UndoListener)\\ \hline
method&override(actionPerformed(), Undo*Action, AbstractAction), \\
&override(actionPerformed(), Redo*Action, AbstractAction), \\ \hline
statement&init(*,javax.swing.undo.UndoManager), \\
&invoke(UndoManager.undo, actionPerformed(), Undo*Action),\\
& invoke(UndoManager.redo, actionPerformed(), Redo*Action)\\  \hline
\end{tabular*}
 \label{tab:dataset}

We simplify some full names due to space limitation: 

AbstractAction: javax.swing.AbstractAction;

UndoListener: javax.swing.event.UndoableEditListener

actionPerformed():actionPerformed(ActionEvent)
}
 \end{center}
\end{table}



\noindent{\textbf{Example clustering phase.}} After extracting facts for each example, our tool identifies main facts shared in all 5 examples shown in Figure~\ref{fig:fact} part A. It leverages slicing to group related facts. In this example, 3 of them add \codefont{Undo*Action} to \codefont{JMenuItem} by invoking \codefont{JMenuItem.add (ActionEvent)} and support undo and redo actions for Text Editor shown in Figure~\ref{fig:fact} part B. The other two of them invoke \codefont{JButton.addActionListener(ActionEvent)} to add these two actions to \codefont{JButton}, and support \codefont{JApplet} Shape drawing shown in Figure~\ref{fig:fact} part C. After extracting both main facts and related facts, we generate two reuse tasks by combining main facts with each related fact group.  

\noindent{\textbf{Example integration phase.}} Given a context like Figure~\ref{fig:context} part D, our tool identifies the best-fit reuse task based on the number of matched facts in the user's context.  If our tool fails to identify any matched facts in the user's context, it will simply rank the reuse task based on its occurrence in the code examples. Our tool asks for user's selection by presenting the generated main facts and related facts to the user in the form of code snippet. 
After confirmed by users, our tool automatically fills the rest facts that do not exist in the context shown in Figure~\ref{fig:context} part E. 
\end{comment}

