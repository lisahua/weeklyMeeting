\section{Motivating Example}

Consider a reuse task to implement a drag-and-drop plugin called \tool for Eclipse to support systematic editing~\cite{Meng:sydit11}. As shown in Figure~\ref{fig:clipboard}, users drag and drop the method they want to edit to \tool before editing. When they finish changing the method, they take another snapshot using drag-and-drop. \tool will automatically recommend locations that  are similar to the given example, and recommend similar but not identical edits based on similar context. 

To complete this task, developer first queries Google code search (GCS) using the query \codefont{Eclipse plugin drag and drop to table}. We choose GCS because existing code example recommendation tools like Strathcona~\cite{Holmes:structural05} and code query tools like SNIFF~\cite{sniff:Sen09}  do not fit for such a medium scale reuse task. GCS returns 102 examples. We only analyze the first five returned examples because empirical evidence indicates that developers rarely look beyond this limit when searching~\cite{Starke:searchNum09}. The fourth example is much too long (over 1000 lines) without any explanation and the third and fifth example are duplicated with the first one. Figure~\ref{fig:dndweb} illustrates a snapshot for the first example returned by GCS. It implements a SWT shopping cart application to select items from all grocery items and put them into `My shopping cart' via drag-and-drop (Figure~\ref{fig:cartTable}). The second example implements an example for TODO labels which enables user to drag a TODO label from Editor Panel and drop it in an Eclipse Plugin List View (Figure~\ref{fig:todoList}). This is very similar to the task that requires to drag the source code from Editor Panel to an Eclipse Plugin View, yet we hope to use the table view to record multiple examples for both old version and new version, which is the format used in the first example. 

Our next step is to extract common API calls for drag-and-drop action. It is always hard to distinguish the main functionality and variants via a single example, but with the help of multiple examples, our tool is able to identify the main API calls that provide desired functionality. In this example, we notice that the main API calls will be \{new Viewer(), setTransfer(), setOperation(), addDragSupport(), addDropSupport()\} given the hierarchical fact that both \codefont{TableViewer} and \codefont{ListViewer} are subclasses of \codefont{Viewer}. 

After identifying the main API calls (and corresponding control structure), we investigate related elements for these API calls. The implementation of \{DropTargetListener, DragSourceListener\} are identified as common coupling elements, while \{TodoModelProvider, TableItem, GridLayout\} are excluded as they do not have corresponding mapping in the other example. We notice that we should override \{DropTargetListener.drop(), DragSourceListener. 

\noindent{dragSetData()\} to help us finish the drag-and-drop reuse task.}


