\section{Related Work}\label{sec:related}

\tool is related to a number of works on API completion and program synthesis. 


\noindent{\textbf{API completion.}}   \textsc{Prospector}~\cite{jungloid:pldi05} is one of the first works that introduces the notion of synthesizing   ``jungloid code snippets''. A \textit{jungloid} is a composition of single-argument methods with a single return type.  \textsc{Prospector} synthesizes method sequence based on the  \textit{jungloids} mined from existing code corpus. Similar to  \textsc{Prospector},  \textsc{CodeHint}~\cite{codehint:icse14} leverages empirical statistic models to prioritize runtime recommendation for the API completion. It allows users to set up breakpoints in Eclipse IDE, and rollbacks to the previous state whenever the select candidate encounters a runtime exception or test failure. In contrast to the tools with expensive state restoration, \tool simply backtracks till the beginning of the program and re-executes the next candidate. 

\spt~\cite{isil:sypet17} further extends  \textsc{Prospector} by introducing Petri-net for reachability analysis based on SAT solvers. We believe their reachability analysis is complementary to ours, yet in this paper, we show that using a relatively simple test-execution-driven approach for API synthesis, \tool compares generally well with \spt and further supports non-straight-line code synthesis in real-world projects. 

A line of other tools~\cite{mineAPI:msr13, tienAPI:icse14, portfolio:icse13, parseWeb:tao07} mine API usage pattern from the code repositories and  use empirical probabilistic models to guide the search towards methods that are more often used in practice. In particular,  \textsc{Slang}~\cite{slang:pldi14} predicts probabilities of API calls using statistical models based on machine learning,  while Strathcona~\cite{strathcona:icse05} assists developers in finding relevant API invocations from similar program contexts. Different from these techniques that train offline data corpus for API completion, \tool leverages runtime information for search space prioritization. We envision that  empirical statistical models can be helpful to our method sequence prioritization.

\noindent{\textbf{Program Synthesis.}}  Program synthesis has  achieved many success on synthesizing code in small well-defined domains such as bit-vector logic~\cite{oracle:icse10} and data structures~\cite{storyboard:fse11, demsky:issta06} based on test cases~\cite{testDriven:pldi14} or specifications~\cite{Kuncak:pldi10, cegis:13}. These tools transform partial programs~\cite{sketch:sttt13}, input-output examples~\cite{isil:pldi15, singh:pldi13}, or oracles~\cite{oracle:icse10, loop:pldi11} to decision procedures and SMT solvers, and have shown as very efficient in certain domains that have been fully modeled~\cite{insynth:cav11, verifySys:popl10}.  Other synthesis tools try to generate small code snippets.  Perelman et al.\/~\cite{typed:pldi12} infer partial expressions using type-directed completion and   \textsc{InSynth}~\cite{insynth:cav11}  handles high-order functions and polymorphism using theorem proving.  Yet both are confined to single-statement-generation rather than the method sequence.    Recent works leverages natural language queries~\cite{freeQuery:oopsla15, sniff:fase09, sumit:icse16} to infer expressions and simple method invocations, whereas \tool could synthesize code in a much large scope: multiple method invocations in if-conditions and while-loops using real-world Java libraries. 


Our idea of asking users to provide a program skeleton with non-deterministic expressions has the same spirit of sketch-based synthesis~\cite{sketch:aplas09}.  The Sketch system~\cite{sketch:sttt13} asks programmers to write a program sketch containing ``holes'', and uses counter-example-guided inductive synthesis to complete the holes.  \textsc{Jsketch} brings the sketch-based synthesis to Java~\cite{jsketch:fse15}. Given a partial Java program written in the sketch syntax, \textsc{Jsketch} translates the Java program to SAT-based sketch synthesizer and transfers the synthesizer result back to executable Java code. Whereas it support a limited number of libraries.  Our synthesis approach based on  test-execution-driven is also similar to other test-driven synthesis techniques~\cite{verifySys:popl10, testDriven:pldi14}, yet we focus on a more complex scenario of synthesizing Java method invocations with if-conditions and while loops in open source projects. 



